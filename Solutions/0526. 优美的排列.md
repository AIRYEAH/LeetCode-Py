# [0526. 优美的排列](https://leetcode.cn/problems/beautiful-arrangement/)

- 标签：位运算、数组、动态规划、回溯、状态压缩
- 难度：中等

**描述**：给定一个整数 $n$。

**要求**：返回可以构造的「优美的排列」的数量。

**说明**：

- **优美的排列**：假设有 $1 \sim n$ 的 $n$ 个整数。如果用这些整数构造一个数组 $perm$（下标从 $1$ 开始），使得数组第 $i$ 位元素 $perm[i]$ 满足下面两个条件之一，则该数组就是一个「优美的排列」：
  - $perm[i]$ 能够被 $i$ 整除；
  - $i$ 能够被 $perm[i]$ 整除。

- $1 \le n \le 15$。

**示例**：

- 示例 1：

```Python
输入：n = 2
输出：2
解释：
第 1 个优美的排列是 [1,2]：
    - perm[1] = 1 能被 i = 1 整除
    - perm[2] = 2 能被 i = 2 整除
第 2 个优美的排列是 [2,1]:
    - perm[1] = 2 能被 i = 1 整除
    - i = 2 能被 perm[2] = 1 整除
```

- 示例 2：

```Python
输入：n = 1
输出：1
```

## 解题思路

### 思路 1：回溯算法

这道题可以看做是「[0046. 全排列](https://leetcode.cn/problems/permutations/)」的升级版。

1. 通过回溯算法我们可以将数组的所有排列情况列举出来。
2. 因为只有满足第 $i$ 位元素能被 $i$ 整除，或者满足 $i$ 能整除第 $i$ 位元素的条件下才符合要求，所以我们可以进行剪枝操作，不再考虑不满足要求的情况。
3. 最后回溯完输出方案数。

### 思路 1：代码

```Python
class Solution:
    def countArrangement(self, n: int) -> int:
        ans = 0
        visited = set()

        def backtracking(index):
            nonlocal ans
            if index == n + 1:
                ans += 1
                return

            for i in range(1, n + 1):
                if i in visited:
                    continue
                if i % index == 0 or index % i == 0:
                    visited.add(i)
                    backtracking(index + 1)
                    visited.remove(i)

        backtracking(1)
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n!)$，其中 $n$ 为给定整数。
- **空间复杂度**：$O(n)$，递归栈空间大小为 $O(n)$。

### 思路 2：状态压缩 DP

因为 $n$ 最大只有 $15$，所以我们可以考虑使用「状态压缩」。

「状态压缩」指的是使用一个 $n$ 位的二进制数来表示排列中数的选取情况。

举个例子：

1. $n = 4, state = (1001)_2$，表示选择了数字 $1、4$，剩余数字 $2$ 和 $3$ 未被选择。
2. $n = 6, state = (011010)_2$，表示选择了数字 $2、4、5$，剩余数字 $1、3、6$ 未被选择。

###### 1. 划分阶段

按照排列的数字个数、数字集合的选择情况进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][state]$ 表示为：考虑前 $i$ 个数，且当数字集合的选择情况为 $state$ 时的方案数。

###### 3. 状态转移方程



###### 4. 初始条件



###### 5. 最终结果



### 思路 2：代码

```Python

```

### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 为给定整数。
- **空间复杂度**：$O(n \times 2^n)$。

### 思路 3：状态压缩 DP + 优化

###### 1. 划分阶段

按照数字集合的选择情况进行阶段划分。

###### 2. 定义状态

定义状态 $dp[state]$ 表示为：当数字集合的选择情况为 $state$ 时的方案数。

###### 3. 状态转移方程

对于状态 $state$，先统计出 $state$ 中选择的数字个数（即统计二进制中 $1$ 的个数）$num$。

则 $dp[state]$ 表示选择了 $num$ 个数字，且选择情况为 $state$ 时的方案数。那么 $dp[state]$ 的状态必然会 $num - 1$ 个数字对应状态转移而来。

举个例子，比如：$n = 4, state = (1001)_2$，$dp[(1001)_2]$ 表示排列前 $2$ 位选择了数字 $1、4$ 的方案数。而状态 $dp[(1001)_2]$  只能从 $dp[(1000)_2]$（表示排列前 $1$ 位选择了 $4$ 的方案数）和 $dp[(0001)_2]$（表示排列前 $1$ 位选择了数字 $1$ 的方案数）两种状态转移而来。

###### 4. 初始条件

- 不考虑任何数的情况下，方案书为 $1$，即：$dp[0] = 1$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[state]$ 表示为：当数字集合选择状态为 $state$ 时「优美的排列」的方案数。所以最终结果为 $dp[1 << n -  1]$。

### 思路 3：代码

```Python
class Solution:
    def countArrangement(self, n: int) -> int:
        states = 1 << n
        dp = [0 for _ in range(states)]
        dp[0] = 1

        for state in range(states):
            num = bin(state).count("1")
            for i in range(n):
                if state >> i & 1 and (num % (i + 1) == 0 or (i + 1) % num == 0):
                    dp[state] += dp[state ^ (1 << i)]

        return dp[states - 1]
```

### 思路 3：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 为给定整数。
- **空间复杂度**：$O(2^n)$。
