# [1994. 好子集的数目](https://leetcode.cn/problems/the-number-of-good-subsets/)

- 标签：位运算、数组、数学、动态规划、状态压缩
- 难度：困难

## 题目大意

**描述**：给定一个整数数组 $nums$。

**要求**：返回 $nums$ 中不同的好子集的数目对 $10^9 + 7$ 取余的结果。

**说明**：

- **子集**：通过删除 $nums$ 中一些（可能一个都不删除，也可能全部都删除）元素后剩余元素组成的数组。如果两个子集删除的下标不同，那么它们被视为不同的子集。
  
- **好子集**：如果 $nums$ 的一个子集中，所有元素的乘积可以表示为一个或多个互不相同的质数的乘积，那么我们称它为好子集。
  - 比如，如果 `nums = [1, 2, 3, 4]`：
    - `[2, 3]` ，`[1, 2, 3]` 和 `[1, 3]` 是好子集，乘积分别为 `6 = 2*3` ，`6 = 2*3` 和 `3 = 3` 。
    - `[1, 4]` 和 `[4]` 不是好子集，因为乘积分别为 `4 = 2*2` 和 `4 = 2*2` 。

- $1 \le nums.length \le 10^5$。
- $1 \le nums[i] \le 30$。

**示例**：

- 示例 1：

```Python
输入：nums = [1,2,3,4]
输出：6
解释：好子集为：
- [1,2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [1,2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [1,3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同的质数 2 和 3 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
```

- 示例 2：

```Python
输入：nums = [4,2,3,15]
输出：5
解释：好子集为：
- [2]：乘积为 2 ，可以表示为质数 2 的乘积。
- [2,3]：乘积为 6 ，可以表示为互不相同质数 2 和 3 的乘积。
- [2,15]：乘积为 30 ，可以表示为互不相同质数 2，3 和 5 的乘积。
- [3]：乘积为 3 ，可以表示为质数 3 的乘积。
- [15]：乘积为 15 ，可以表示为互不相同质数 3 和 5 的乘积。
```

## 解题思路

### 思路 1：状态压缩 DP



### 思路 1：代码

```Python
class Solution:
    def numberOfGoodSubsets(self, nums: List[int]) -> int:
        MOD = 10 ** 9 + 7
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

        cnts = Counter(nums)
        dp = [0 for _ in range(1 << len(primes))]
        dp[0] = pow(2, cnts[1], MOD)

        for num, cnt in cnts.items():               # 遍历 nums 中所有数及其频数
            if num == 1:                            # 跳过 1
                continue
            flag = True                             # 判断当前子集是否满足互不相同的质数相乘
            cur_num = num
            cur_state = 0
            for i, prime in enumerate(primes):
                cur_cnt = 0
                while cur_num % prime == 0:
                    cur_cnt += 1
                    cur_state = cur_state | 1 << i
                    cur_num //= prime
                if cur_cnt > 1:
                    flag = False
                    break
            if not flag:
                continue
            
            for state in range(1 << len(primes)):
                # 
                if state & cur_state == 0:
                    dp[state | cur_state] = (dp[state | cur_state] + dp[state] * cnts[num]) % MOD
            
        ans = 0
        for i in range(1, 1 << len(primes)):
            ans = (ans + dp[i]) % MOD

        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：
- **空间复杂度**：
