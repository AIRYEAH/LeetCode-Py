# [0698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

- 标签：位运算、记忆化搜索、数组、动态规划、回溯、状态压缩
- 难度：中等

## 题目大意

**描述**：给定一个整数数组 $nums$ 和一个正整数 $k$。

**要求**：找出是否有可能把这个数组分成 $k$ 个非空子集，其总和都相等。

**说明**：

- $1 \le k \le len(nums) \le 16$。
- $0 < nums[i] < 10000$。
- 每个元素的频率在 $[1, 4]$ 范围内。

**示例**：

- 示例 1：

```Python
输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
```

- 示例 2：

```Python
输入: nums = [1,2,3,4], k = 3
输出: False
```

## 解题思路

### 思路 1：状态压缩 DP

### 思路 1：代码

```Python
class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        total = sum(nums)
        target = total // k
        if total % k != 0 or nums[-1] > target:
            return False
        
        nums.sort()
        size = len(nums)
        states = 1 << size
        cur_sum = [0 for _ in range(states)]
        dp = [False for _ in range(states)]
        dp[0] = True

        for state in range(states):
            if not dp[state]:
                continue
            for k in range(size):
                if state & (1 << k) != 0:
                    continue
                
                next_state = state | (1 << k)
                if dp[next_state]:
                    continue
                
                if cur_sum[state] % target + nums[k] > target:
                    break
                cur_sum[next_state] = cur_sum[state] + nums[k]
                dp[next_state] = True
                
        return dp[states - 1]
```

### 思路 1：复杂度分析

- **时间复杂度**：
- **空间复杂度**：

