# [0788. 旋转数字](https://leetcode.cn/problems/rotated-digits/)

- 标签：数学、动态规划
- 难度：中等

## 题目大意

**描述**：给定搞一个正整数 $n$。

**要求**：计算从 $1$ 到 $n$ 中有多少个数 $x$ 是好数。

**说明**：

- **好数**：如果一个数 $x$ 的每位数字逐个被旋转 180 度之后，我们仍可以得到一个有效的，且和 $x$ 不同的数，则成该数为好数。
- 如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。$0$、$1$ 和 $8$ 被旋转后仍然是它们自己；$2$ 和 $5$ 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，$2$ 和 $5$ 互为镜像）；$6$ 和 $9$ 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。
- $n$ 的取值范围是 $[1, 10000]$。

**示例**：

- 示例 1：

```Python
输入: 10
输出: 4
解释: 
在 [1, 10] 中有四个好数： 2, 5, 6, 9。
注意 1 和 10 不是好数, 因为他们在旋转之后不变。
```

## 解题思路

### 思路 1：枚举算法

根据题目描述，一个数中至少出现一次 $2$、$5$、$6$ 或 $9$，就是好数。

因此，我们可以枚举 $[1, n]$ 中的每一个正整数 $x$，并判断该正整数 $x$ 的数位中是否出现了 $2$、$5$、$6$ 或 $9$，如果出现了，则该正整数 $x$ 位好数，否则不是好数。

最后统计好数的方案个数并将其返回即可。

### 思路 1：代码

```Python
class Solution:
    def rotatedDigits(self, n: int) -> int:
        check = [0, 0, 1, -1, -1, 1, 1, -1, 0, 1]
        ans = 0
        for i in range(1, n + 1):
            flag = False
            num = i
            while num:
                digit = num % 10
                num //= 10
                if check[digit] == 1:
                    flag = True
                elif check[digit] == -1:
                    flag = False
                    break
            if flag:
                ans += 1
            	
        return ans
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times \log n)$。
- **空间复杂度**：$O(\log n)$。

### 思路 2：动态规划 + 数位 DP

### 思路 2：代码

```Python
```

### 思路 2：复杂度分析

- **时间复杂度**：$O(\log n)$。
- **空间复杂度**：$O(\log n)$。

