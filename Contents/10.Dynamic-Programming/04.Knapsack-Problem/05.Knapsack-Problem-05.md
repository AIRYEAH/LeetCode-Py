## 8. 背包问题变种

### 8.1 背包问题恰好装满背包使价值最大



### 8.2 背包问题求方案总数

> **背包问题求方案数**：在给定背包重量 $W$，每件物品重量 $weight[i]$，物品间相互关系（分组、依赖等）的背包问题中。求解出装满背包或将背包装至某一指定重量的方案总数。

这种问题就是将原有状态转移方程中的「求最大值」变为「求和」即可。

下面我们以「0-1 背包问题」求方案总数为例。

> **0-1 背包问题求解方案数**：有 $n$ 件物品和有一个最多能装重量为 $W$ 的背包。第 $i$ 件物品的重量为 $weight[i]$，价值为 $value[i]$，每件物品有且只有 $1$ 件。请问装满重量为 $W$ 的背包，一共有多少种方案？

#### 思路 2：动态规划 + 一维状态

如果使用二维状态定义，可定义状态 $dp[i][w]$ 为：前 $i$ 件物品放入一个最多能装重量为 $w$ 的背包中的方案总数。则状态转移方程为：$dp[i][w] = dp[i - 1][w] + dp[i][w - weight[i - 1]]$。

如果使用一维状态定义：

1. **划分阶段**：按照物品种类的序号、当前背包的载重上限进行阶段划分。
2. **定义状态**：定义状态 $dp[w]$ 表示为：将物品装入一个最多能装重量为 $w$ 的背包中的方案总数。
3. **状态转移方程**：$dp[w] = dp[w] + dp[w - weight[i - 1]]$
4. **初始条件**：如果背包载重上限为 $0$，则一共有 $1$ 种方案（什么也不装），即 $dp[0] = 1$。
5. **最终结果**：根据我们之前定义的状态， $dp[w]$ 表示为：将物品装入最多能装重量为 $w$ 的背包中的方案总数。则最终结果为 $dp[W]$，其中 $W$ 为背包的载重上限。

#### 思路 2：代码

```Python
class Solution:
    # 0-1 背包问题求方案总数
    def zeroOnePackNumbers(self, weight: [int], value: [int], W: int):
        size = len(weight)
        dp = [0 for _ in range(W + 1)]
        dp[0] = 1
        
        # 枚举前 i 种物品
        for i in range(1, size + 1):
            # 逆序枚举背包装载重量
            for w in range(W, weight[i - 1] - 1, -1):
                # dp[w] = 前 i - 1 件物品装入载重为 w 的背包中的方案数 + 前 i 件物品装入载重为 w - weight[i - 1] 的背包中，再装入第 i - 1 件物品的方案数
                dp[w] = dp[w] + dp[w - weight[i - 1]]
                
        return dp[W]
```

#### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times W)$，其中 $n$ 为物品种类数量，$W$ 为背包的载重上限。
- **空间复杂度**：$O(W)$。

### 8.3 背包问题求最优方案数

> **背包问题求最优方案数**：在给定背包重量 $W$，每件物品重量 $weight[i]$、物品价值 $value[i]$，物品间相互关系（分组、依赖等）的背包问题中。请问在总重量不超过背包载重上限的情况下，使背包总价值最大的方案数是多少？

通过结合「求背包最大可得价值」和「求方案数」两个问题的思路，我们可以分别定义两个状态：

1. 定义 $dp[i][w]$ 表示为：前 $i$ 种物品放入一个最多能装重量为 $w$ 的背包中，可获得的最大价值。
2. 定义 $op[i][w]$ 表示为：前 $i$ 种物品放入一个最多能装重量为 $w$ 的背包中，使背包总价值最大的方案数。

下面我们以「0-1 背包问题」求最优方案数为例。

> **0-1 背包问题求解方案数**：有 $n$ 种物品和一个最多能装重量为 $W$ 的背包，第 $i$ 种物品的重量为 $weight[i]$，价值为 $value[i]$，每件物品有且只有 $1$ 件。请问在总重量不超过背包载重上限的情况下，使背包总价值最大的方案数是多少？

#### 思路 3：动态规划

1. **划分阶段**：按照物品种类的序号、当前背包的载重上限进行阶段划分。
2. **定义状态**：
   1. 定义 $dp[i][w]$ 表示为：前 $i$ 种物品放入一个最多能装重量为 $w$ 的背包中，可获得的最大价值。
   2. 定义 $op[i][w]$ 表示为：前 $i$ 种物品放入一个最多能装重量为 $w$ 的背包中，使背包总价值最大的方案数。
3. **状态转移方程**：
   1. 如果 $dp[i - 1][w] < dp[i - 1][w - weight[i - 1]] + value[i - 1]$，则说明选择第 $i - 1$ 件物品获得价值更高，此时方案数 $op[i][w]$ 是在 $op[i - 1][w - weight[i - 1]]$ 基础上添加了第 $i - 1$ 件物品，因此方案数不变，即：$op[i][w] = op[i - 1][w - weight[i - 1]]$。
   2. 如果 $dp[i - 1][w] = dp[i - 1][w - weight[i - 1]] + value[i - 1]$，则说明选择与不选择第 $i - 1$ 件物品获得价格相等，此时方案数应为两者之和，即：$op[i][w] = op[i - 1][w] + op[i - 1][w - weight[i - 1]]$。
   3. 如果 $dp[i - 1][w] > dp[i - 1][w - weight[i - 1]] + value[i - 1]$，则说明不选择第 $i - 1$ 件物品获得价值更高，此时方案数等于之前方案数，即：$op[i][w] = op[i - 1][w]$。
4. **初始条件**：如果背包载重上限为 $0$，则一共有 $1$ 种方案（什么也不装），即 $dp[0] = 1$。
5. **最终结果**：根据我们之前定义的状态， $op[i][w]$ 表示为：前 $i$ 种物品放入一个最多能装重量为 $w$ 的背包中，使背包总价值最大的方案数。则最终结果为 $op[size][W]$，其中 $size$ 为物品的种类数，$W$ 为背包的载重上限。

#### 思路 3：代码

```Python
class Solution:
    # 0-1 背包问题求最优方案数 思路 1
    def zeroOnePackMaxProfitNumbers1(self, weight: [int], value: [int], W: int):
        size = len(weight)
        dp = [[0 for _ in range(W + 1)] for _ in range(size + 1)]
        op = [[1 for _ in range(W + 1)] for _ in range(size + 1)]
        
        # 枚举前 i 种物品
        for i in range(1, size + 1):
            # 枚举背包装载重量
            for w in range(W + 1):
                # 第 i - 1 件物品装不下
                if w < weight[i - 1]:
                    # dp[i][w] 取「前 i - 1 种物品装入载重为 w 的背包中的最大价值」
                    dp[i][w] = dp[i - 1][w]
                    op[i][w] = op[i - 1][w]
                else:
                    # 选择第 i - 1 件物品获得价值更高
                    if dp[i - 1][w] < dp[i - 1][w - weight[i - 1]] + value[i - 1]:
                        dp[i][w] = dp[i - 1][w - weight[i - 1]] + value[i - 1]
                        # 在之前方案基础上添加了第 i - 1 件物品，因此方案数量不变
                        op[i][w] = op[i - 1][w - weight[i - 1]]
                    # 两种方式获得价格相等
                    elif dp[i - 1][w] == dp[i - 1][w - weight[i - 1]] + value[i - 1]:
                        dp[i][w] = dp[i - 1][w]
                        # 方案数 = 不使用第 i - 1 件物品的方案数 + 使用第 i - 1 件物品的方案数
                        op[i][w] = op[i - 1][w] + op[i - 1][w - weight[i - 1]]
                    # 不选择第 i - 1 件物品获得价值最高
                    else:
                        dp[i][w] = dp[i - 1][w]
                        # 不选择第 i - 1 件物品，与之前方案数相等
                        op[i][w] = op[i - 1][w]
                        
        return op[size][W]
```

#### 思路 3：复杂度分析

- **时间复杂度**：$O(n \times W)$，其中 $n$ 为物品种类数量，$W$ 为背包的载重上限。
- **空间复杂度**：$O(n \times W)$。

### 8.4 背包问题输出方案